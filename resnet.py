# encoding: utf-8"""@Time: 2021-07-19 15:09 @Author: Libing Wang@File: resnet.py @description: 实现 ResNet45 网络"""import mathimport torchimport torch.nn as nndef conv1_1(in_planes, out_planes, stride=(1, 1)):    return nn.Conv2d(in_planes, out_planes, kernel_size=(1, 1), stride=stride, bias=False)def conv3_3(in_planes, out_planes, stride=(1, 1)):    return nn.Conv2d(in_planes, out_planes, kernel_size=(3, 3), stride=stride, padding=(1, 1), bias=False)class BasicBlock(nn.Module):    """构建残差快"""    expansion = 1    def __init__(self, in_planes, planes, stride=1, down_sample=None):        super(BasicBlock, self).__init__()        self.conv1 = conv1_1(in_planes, planes)        self.bn1 = nn.BatchNorm2d(planes)        self.relu = nn.ReLU(inplace=True)        self.conv2 = conv3_3(planes, planes, stride)        self.bn2 = nn.BatchNorm2d(planes)        self.down_sample = down_sample        self.stride = stride    def forward(self, x):        residual = x        out = self.conv1(x)        out = self.bn1(out)        out = self.relu(out)        out = self.conv2(out)        out = self.bn2(out)        if self.down_sample is not None:            residual = self.down_sample(x)        out += residual        out = self.relu(out)        return outclass ResNet(nn.Module):    def __init__(self, block, layers_num, strides):        super(ResNet, self).__init__()        self.in_plane = 32        self.conv1 = nn.Conv2d(1, 32, kernel_size=(3, 3), padding=(1, 1), stride=strides[0], bias=False)        self.bn1 = nn.BatchNorm2d(32)        self.relu = nn.ReLU(inplace=True)        self.layer1 = self._make_layer(block, 32, layers_num[0], stride=strides[1])        self.layer2 = self._make_layer(block, 64, layers_num[1], stride=strides[2])        self.layer3 = self._make_layer(block, 128, layers_num[2], stride=strides[3])        self.layer4 = self._make_layer(block, 256, layers_num[3], stride=strides[4])        self.layer5 = self._make_layer(block, 512, layers_num[4], stride=strides[5])        for m in self.modules():            if isinstance(m, nn.Conv2d):                n = m.kernel_size[0] * m.kernel_size[1] * m.out_channels                m.weight.data.normal_(0, math.sqrt(2. / n))            elif isinstance(m, nn.BatchNorm2d):                m.weight.data.fill_(1)                m.bias.data.zero_()    def _make_layer(self, block, plane, layers_num, stride=(1, 1)):        down_sample = None        if stride != (1, 1) or self.in_plane != plane * block.expansion:            down_sample = nn.Sequential(                nn.Conv2d(self.in_plane, plane * block.expansion, kernel_size=(1, 1), stride=stride, bias=False),                nn.BatchNorm2d(plane * block.expansion)            )        layers = [block(self.in_plane, plane, stride, down_sample)]        self.in_plane = plane * block.expansion        for i in range(1, layers_num):            layers.append(block(self.in_plane, plane))        return nn.Sequential(*layers)    def forward(self, x, multi_scale=False):        out_features = []        x = self.conv1(x)        x = self.bn1(x)        x = self.relu(x)        temp_shape = x.size()[2:]        x = self.layer1(x)        if x.size()[2:] != temp_shape:            temp_shape = x.size()[2:]            out_features.append(x)        # --------------------------------        x = self.layer2(x)        if x.size()[2:] != temp_shape:            temp_shape = x.size()[2:]            out_features.append(x)        # --------------------------------        x = self.layer3(x)        if x.size()[2:] != temp_shape:            temp_shape = x.size()[2:]            out_features.append(x)        # --------------------------------        x = self.layer4(x)        if x.size()[2:] != temp_shape:            out_features.append(x)        # --------------------------------        x = self.layer5(x)        out_features.append(x)        return out_featuresdef resnet_45(strides):    model = ResNet(BasicBlock, [3, 4, 6, 6, 3], strides)    return modelif __name__ == '__main__':    model = resnet_45([(1, 1), (2, 2), (1, 1), (2, 2), (1, 1), (1, 1)])    pseudo_input = torch.rand(1, 1, 32, 128)    outs = model(pseudo_input)    for out in outs:        print(out.shape)