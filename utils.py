# encoding: utf-8"""@Time: 2021-07-19 16:09 @Author: Libing Wang@File: utils.py @description: """import torchimport editdistance as edimport torch.nn.functional as Fclass CharacterTransTool:    """encoder & decoder"""    def __init__(self, dict_file, case_sensitive=True):        self.dict = []        self.case_sensitive = case_sensitive        with open(dict_file, 'r', encoding="utf-8") as fl:            lines = fl.readlines()            for line in lines:                self.dict.append(line.strip("\n"))    def encode(self, label_batch):        max_len = max(list(map(len, label_batch)))        out = torch.zeros(len(label_batch), max_len + 1).long()        for i in range(len(label_batch)):            if not self.case_sensitive:                # TODO 为什么 + 1                cur_encoded = torch.tensor(                    [self.dict.index(char.lower()) if char.lower() in self.dict else len(self.dict) for char in                     label_batch[i]]                ) + 1            else:                cur_encoded = torch.tensor(                    [self.dict.index(char) if char in self.dict else len(self.dict) for char in label_batch[i]]                ) + 1            out[i][0: len(cur_encoded)] = cur_encoded        return out    def decode(self, net_out, length):        """        length        """        # TODO 这个 length 代表什么意思        out = []        out_prob = []        net_out = F.softmax(net_out, dim=1)        for i in range(length.shape[0]):            # TODO 这块没看懂            current_idx_list = net_out[int(length[: i].sum()): int(length[: i].sum() + length[i])].topk(1)[1][:, 0]\                .tolist()            current_text = ''.join(                [self.dict[item - 1] if 0 < item <= len(self.dict) else '' for item in current_idx_list])            current_prob = net_out[int(length[: i].sum()): int(length[: i].sum() + length[i])].topk(1)[0][:, 0]            current_prob = torch.exp(torch.log(current_prob).sum() / current_prob.size()[0])            out.append(current_text)            out_prob.append(current_prob)        return [out, out_prob]class AccCounter:    """统计 Accuracy"""    def __init__(self, dis_str, dict_file, case_sensitive):        self.correct = 0        self.total_samples = 0.        self.distance_C = 0        self.total_C = 0.        self.distance_W = 0        self.total_W = 0.        self.dis_str = dis_str        self.case_sensitive = case_sensitive        self.character_tool = CharacterTransTool(dict_file, case_sensitive)    def clear(self):        self.correct = 0        self.total_samples = 0.        self.distance_C = 0        self.total_C = 0.        self.distance_W = 0        self.total_W = 0.    def add_iter(self, output, out_length, label_length, labels):        self.total_samples += label_length.size()[0]        pred_texts, pred_probs = self.character_tool.decode(output, out_length)        for i in range(len(pred_texts)):            if not self.case_sensitive:                pred_texts[i] = pred_texts[i].lower()                labels[i] = labels[i].lower()            all_words = []            for w in labels[i].split('|') + pred_texts[i].split('|'):                if w not in all_words:                    all_words.append(w)            label_words = [all_words.index(c) for c in labels[i].split('|')]            pred_words = [all_words.index(c) for c in pred_texts[i].split('|')]            self.distance_C += ed.eval(labels[i], pred_texts[i])            self.distance_W += ed.eval(label_words, pred_words)            self.total_C += len(labels[i])            self.total_W += len(label_words)            self.correct = self.correct + 1 if labels[i] == pred_texts[i] else self.correct    def show(self):        print(self.dis_str)        print("Acc: {:.6f}, AR: {:.6f}, CER: {:.6f}, WER: {:.6f}".format(            self.correct / self.total_samples,            1 - self.distance_C / self.total_C,            self.distance_C / self.total_C,            self.distance_W / self.total_W        ))        acc = self.correct / self.total_samples        ar = 1 - self.distance_C / self.total_C        cer = self.distance_C / self.total_C        wer = self.distance_W / self.total_W        self.clear()        return acc, ar, cer, werclass LossCounter:    def __init__(self, dis_interval):        self.dis_interval = dis_interval        self.total_iters = 0.        self.loss_sum = 0    def add_iter(self, loss):        self.total_iters += 1        self.loss_sum += float(loss)    def clear(self):        self.total_iters = 0        self.loss_sum = 0    def get_loss(self):        loss = self.loss_sum / self.total_iters if self.total_iters > 0 else 0        self.clear()        return loss